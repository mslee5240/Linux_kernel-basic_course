# Linux Kernel Interrupt

## 1. 인터럽트의 중요성

### 정의
하드웨어 변경사항을 CPU에 알리는 신호

### 핵심 역할
- **주변 장치 제어**: 키보드, 마우스, 네트워크 카드 등 하드웨어 이벤트 처리
- **커널 이해**: 리눅스 커널의 비동기 이벤트 처리 메커니즘 파악
- **시스템 최적화**: 폴링 대신 이벤트 기반 처리로 CPU 효율성 향상

### 디바이스 드라이버 개발에서의 중요성
하드웨어와 소프트웨어 간 실시간 통신 구현의 기반

> 인터럽트 없이는 현대적인 반응형 시스템 구축이 불가능합니다.

<br>

## 2. CPU 인터럽트 처리 과정

### 2.1 인터럽트 = 예외
- 인터럽트는 CPU 예외(exception)의 한 유형
- 정상 실행 흐름을 중단시키는 이벤트

### 2.2 처리 메커니즘
- **현재 실행 중단**: CPU가 진행 중인 명령어 처리를 멈춤
- **예외 벡터 테이블**: 각 인터럽트/예외 유형별 핸들러 주소가 저장된 테이블
- **주소 점프**: 해당 인터럽트 서비스 루틴(ISR) 주소로 프로그램 카운터 변경

### 2.3 아키텍처별 구현
- **ARMv7-A**: 예외 벡터 테이블 기반 처리
- **벡터 테이블**: 고정된 메모리 위치에 각 예외 유형별 핸들러 주소 배치

### 2.4 실행 흐름
```
현재 코드 → 인터럽트 발생 → 벡터 테이블 참조 → ISR 실행 → 원래 코드로 복귀
```

<br>

## 3. Top-Half와 Bottom-Half

### 3.1 인터럽트 핸들러(Top-Half) 설계 원칙

#### 핵심 이유
프로세스 실행 중단 최소화로 시스템 성능 보호

#### 주요 개념
- **실행 중단**: 인터럽트 발생 시 현재 프로세스가 강제 중단됨
- **응답성 저하**: 긴 핸들러 → 시스템 전체 반응 속도 감소
- **분할 처리**: Top-Half(긴급 작업) + Bottom-Half(지연 가능 작업)

#### 설계 방법
- **Top-Half**: 하드웨어 응답, 중요 상태 저장만
- **Bottom-Half**: 복잡한 처리는 나중에 실행

#### 결과
인터럽트 지연 시간 최소화로 전체 시스템 성능 유지

### 3.2 인터럽트 Bottom-Half 처리 기법

#### 리눅스 커널 제공 기법
- **IRQ 스레드**: 프로세스 컨텍스트에서 인터럽트 처리
- **Soft IRQ**: 소프트웨어 인터럽트 기반 처리
- **Tasklet**: Soft IRQ 위에 구현된 간단한 지연 처리
- **Workqueue**: 워커 스레드 풀 기반 작업 큐

#### Polling vs 인터럽트
- **Polling**: CPU가 주기적으로 하드웨어 상태 확인 (비효율적)
- **인터럽트**: 하드웨어가 이벤트 발생 시 CPU에 신호 (효율적)

<br>

## 4. 인터럽트 컨텍스트 제약사항

### 금지 API
절전 모드(sleep) 진입 함수들

### 핵심 제약
- **슬립 금지**: 인터럽트 컨텍스트에서는 대기/블로킹 불가
- **메모리 할당**: `GFP_ATOMIC` 플래그 필수 (GFP_KERNEL 사용 금지)

### 이유
인터럽트 핸들러가 슬립하면 시스템 데드락 위험

### 대안
논블로킹 API 또는 Bottom-Half로 지연 처리

<br>

## 5. Threaded IRQ

### 처리 주체
독립적인 전용 커널 스레드

### 동작 원리
1. 각 인터럽트마다 전용 커널 스레드 생성
2. Top-Half가 `IRQ_WAKE_THREAD` 반환 시 스레드 깨어남
3. 스레드가 Bottom-Half 작업 수행

### 장점
일반 프로세스처럼 스케줄링 가능, 선점 허용, 슬립 함수 사용 가능

<br>

## 6. 워크큐(Workqueue)

### 6.1 핵심 개념

#### 실행 단위
Work

#### 구조
- **Work 구조체**: 작업 정보를 담는 기본 단위
- **Work Handler 함수**: 실제 수행할 작업 로직
- **연결**: Work 구조체에 Handler 함수 포인터 등록

#### 특징
프로세스 컨텍스트에서 실행되어 슬립 함수 사용 가능

### 6.2 실행 메커니즘

#### 실행 주체
Worker Thread (워커 스레드)

#### 동작 과정
1. Work 큐잉 → Worker Thread 깨어남
2. Worker Thread가 Work 추출
3. Work Handler 함수 호출하여 실행

#### 특성
Worker Thread는 커널 스레드로 동작

<br>

## 7. 디버깅 및 분석

### 7.1 Ftrace로 워크큐 분석

#### 유용한 이벤트
- `work_queue_execute_start/end`: Work 실행 시작/종료 추적
- `schedule_switch`: Worker Thread 스케줄링 변경 모니터링

#### 부적합한 이벤트
- `kmalloc_atomic`: 메모리 할당 추적용 (워크큐 동작과 무관)

#### 핵심
워크큐 분석은 Work 실행과 스레드 스케줄링 이벤트에 집중

### 7.2 IRQ 디스크립터(Interrupt Descriptor)

#### 정의
각 인터럽트 번호의 속성 정보를 관리하는 커널 데이터 구조체

#### 관리 정보
- 인터럽트 핸들러 정보
- IRQ 스레드 정보  
- 인터럽트 번호별 속성 데이터

#### 역할
인터럽트 관련 메타데이터의 중앙 집중 관리

## 결론

리눅스 커널의 인터럽트 처리는 시스템 성능과 안정성에 직접적인 영향을 미치는 핵심 기술입니다. Top-Half와 Bottom-Half의 적절한 분리, 다양한 지연 처리 기법의 활용, 그리고 컨텍스트별 제약사항 이해가 효율적인 커널 개발의 기초가 됩니다.