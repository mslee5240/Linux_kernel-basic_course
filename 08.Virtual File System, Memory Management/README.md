# 리눅스 파일 시스템과 메모리 관리

## 1. 가상 파일 시스템 (VFS)

### 주요 역할
**다양한 파일 시스템에 대한 통일된 인터페이스 제공**

#### 핵심 개념
- **추상화 계층**: 하부 파일 시스템의 다양성을 숨김
- **통일된 인터페이스**: 일관된 시스템 콜 인터페이스 제공
- **다양한 파일 시스템**: EXT4, F2FS 등 여러 종류 지원

#### 목적
- 사용자 프로그램과 커널의 다른 부분에서 파일 접근 시 일관성 제공
- 다양한 파일 시스템의 통합 관리


## 2. 파일 객체 (File Object)

### 정의
**프로세스가 특정 파일을 열었을 때 해당 인스턴스를 관리하는 주요 객체**

#### 특징
- **자료구조**: `struct file`
- **생성 시점**: `open()` 시스템 콜 호출 시마다 생성
- **관리 정보**: 
  - 열린 파일 인스턴스의 현재 위치
  - 접근 모드
  - 파일 오퍼레이션

#### 특성
- 같은 파일이라도 여러 프로세스가 열면 파일 객체는 여러 개 존재
- 프로세스별 독립적인 파일 상태 관리


## 3. 메모리 관리 유닛 (MMU)

### 역할
**CPU가 사용하는 가상 주소를 물리 주소로 변환하는 하드웨어 유닛**

#### 위치 및 구조
- **위치**: CPU와 주 메모리 사이에 위치
- **하드웨어 장치**: 전용 하드웨어 유닛

#### 동작 과정
1. CPU가 가상 주소로 메모리 접근 요청
2. MMU가 페이지 테이블 정보 활용
3. 가상 주소를 해당하는 물리 주소로 변환
4. 주 메모리에 접근 가능하게 함


## 4. 페이지 디스크립터 (Page Descriptor)

### 정의
**물리 메모리의 각 페이지에 대한 상태 및 메타데이터를 관리하는 자료구조**

#### 관리 정보
- **페이지 상태**: 사용 중, 가용, 할당 등
- **소유자 정보**: 어떤 프로세스가 사용 중인지
- **매핑 정보**: 가상 주소와의 매핑 관계
- **기타 메타데이터**: 다양한 페이지 관련 정보

#### 중요성
- 물리 메모리 페이지의 기본 단위 관리
- 효율적인 메모리 관리 가능
- 커널의 핵심 자료구조


## 5. 시스템 콜 진입 과정

### 시스템 콜 트랩 발생
**사용자 공간에서 표준 입출력 함수 호출 시 가장 먼저 일어나는 과정**

#### 실행 흐름
1. **사용자 공간**: `read()` 등 표준 입출력 함수 호출
2. **라이브러리**: glibc 등 라이브러리 함수 실행
3. **특수 인스트럭션**: SVC 명령어 등 사용
4. **시스템 콜 트랩**: 트랩 발생
5. **모드 전환**: 사용자 모드에서 커널 모드로 전환
6. **핸들러 진입**: 시스템 콜 핸들러로 진입

#### 핵심 요소
- **CPU 아키텍처**: 모드 전환 지원
- **시스템 콜 핸들러**: 커널 진입점
- **트랩 메커니즘**: 안전한 모드 전환

## 핵심 요점

1. **VFS**: 다양한 파일 시스템의 통일된 추상화 계층
2. **파일 객체**: 열린 파일 인스턴스별 상태 관리
3. **MMU**: 가상-물리 주소 변환 하드웨어
4. **페이지 디스크립터**: 물리 메모리 페이지 메타데이터 관리
5. **시스템 콜 트랩**: 사용자-커널 공간 전환의 시작점

이러한 구성 요소들이 함께 작동하여 리눅스 시스템의 파일 시스템과 메모리 관리를 효율적으로 수행합니다.